[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MTRS-Skript",
    "section": "",
    "text": "Willkommen zum Skript",
    "crumbs": [
      "Willkommen zum Skript"
    ]
  },
  {
    "objectID": "index.html#verbessern",
    "href": "index.html#verbessern",
    "title": "MTRS-Skript",
    "section": "Verbessern",
    "text": "Verbessern\nIch freue mich über alle Fehlerkorrekturen und Verbesserungsvorschläge die mich erreichen. Am einfachsten ist dies via Mail.",
    "crumbs": [
      "Willkommen zum Skript"
    ]
  },
  {
    "objectID": "index.html#mitwirken",
    "href": "index.html#mitwirken",
    "title": "MTRS-Skript",
    "section": "Mitwirken",
    "text": "Mitwirken\nWer am Skriptum mitarbeiten möchte kann mich gerne kontaktieren. Meine Kontaktdaten sind auf der Homepage der HTL-Anichstrasse zu finden.\nViel Vergnügen mit MTRS und dem interaktiven Quarto Book!",
    "crumbs": [
      "Willkommen zum Skript"
    ]
  },
  {
    "objectID": "Messtechnik/Frequenz_und_Periode.html",
    "href": "Messtechnik/Frequenz_und_Periode.html",
    "title": "1  Messung der Zeit, Frequenz und Periode",
    "section": "",
    "text": "1.1 Warum die Frequenz messen\nEs gibt primäre Gründe die Frequenz zu messen wie zum Beipiel in der Frequenztechnik. Dort will man sicherstellen, dass die geqünschte Frequenz auch tatsächlich eingestellt ist. So soll ein WLAN Signal im \\(2,4 \\ \\mathrm{GHz}\\) Bereich auf Kanal 1 zwischen \\(2399,5 \\ \\mathrm{MHz}\\) und \\(2424,5 \\ \\mathrm{MHz}\\) funken. Dies muss Messtechnisch sicherhgestellt werden.\nDa sich Frequenzen aber hervorragend digitalisieren lassen sind Frequenzen auch sehr beliebt als Messignale anderer physikalischer Größen. Zum Beispiel lässt sich die Geschwindigkeit als Frequenz übertragen, wenn bekannt ist, dass jede Periode einem definierten Weg entspicht. \\[ Geschwindigkeit =  \\frac{Weg \\ pro \\ Periode }{Periodendauer} = Weg \\ pro \\ Periode \\cdot Frequenz\\]\nNoch einfacher ist es die Durchflussmenge mittels Frequenz zu übertragen. Dazu muss aus dem Datenblatt gelesen werden wie viel Volumen einer Periode entspricht. \\[ Durchlussmenge = Anzahl \\ der Perioden \\ \\cdot Volumen \\ pro \\ Periode \\]",
    "crumbs": [
      "Messtechnik und Sensorik",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Messung der Zeit, Frequenz und Periode</span>"
    ]
  },
  {
    "objectID": "Messtechnik/Frequenz_und_Periode.html#periodische-signale",
    "href": "Messtechnik/Frequenz_und_Periode.html#periodische-signale",
    "title": "1  Messung der Zeit, Frequenz und Periode",
    "section": "1.2 Periodische Signale",
    "text": "1.2 Periodische Signale\nBevor mit der eigentlichen Messung begonnen wird soll hier noch einmal auf die Grundlagen eingegangen werden. Man spricht von einem periodischen Signal wenn es sich nach einer bestimmten Zeitdauer, der Periodendauer, wiederholt. Ein Sinussignal ist ein Beispiel dafür.\n\n\n\n\n\n\n\n\nAbbildung 1.1: Sinussignal mit drei Perioden\n\n\n\n\n\nDie Einheit der Frequenz ist das Herz \\(f\\). In SI-Baisiseinheiten ausgedrückt ist es der Kehrwert der Zeit \\(\\mathrm{Hz =1/s}\\). Der Zusammenhang zwischen der Periodendauer und der Frequenz lässt sich bereits aus der Einheit der Frequenz ablesen. Es ist wiederum der Kehrwert \\(f = 1/T\\).",
    "crumbs": [
      "Messtechnik und Sensorik",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Messung der Zeit, Frequenz und Periode</span>"
    ]
  },
  {
    "objectID": "Messtechnik/Frequenz_und_Periode.html#messung",
    "href": "Messtechnik/Frequenz_und_Periode.html#messung",
    "title": "1  Messung der Zeit, Frequenz und Periode",
    "section": "1.3 Messung",
    "text": "1.3 Messung\nSowohl die Periodendauer als auch die Frequenz können mit einem ähnlichen Messaufbau gemessen werden.\n\n\n\n\n\n\nAbbildung 1.2: Blockschaltbild der Frequenzmessung\n\n\n\nMit der Information des Zählers und der Frequenz des Taktes kann nun die Frequenz des Signales berechnet werden.\n\n1.3.1 Frequenzmessung\nDie Messung benötigt einen Zähler und einen Takt mit bekannter Periodendauer. Wenn die Anzahl der Perioden in einer bestimmten Zeit gezählt werden, kann daraus die Frequenz und die Periodendauer berechent werden. Die dargestellte Quelle ist symbolisch für das zu messende Signal. Vorraussetzung ist, dass es sich um ein periodisches Signal handelt. Es muss kein Sinussignal sein. Es kann zum Beispiel auch ein Rechteck- oder Sägezahnsignal sein. Sollange das Signal periodisch ist funktioniert die Messung.\n\n\n\n\n\n\n\n\nAbbildung 1.3: Eingangssignal\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbbildung 1.4: Taktsignal und logische Verknüpfung",
    "crumbs": [
      "Messtechnik und Sensorik",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Messung der Zeit, Frequenz und Periode</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/01_Datenanalyse.html",
    "href": "Datenanalyse/01_Datenanalyse.html",
    "title": "Datenanalyse - Data Analysis",
    "section": "",
    "text": "Weiterführende Literatur\nAnalyzing IoT Data with Python Kaggle",
    "crumbs": [
      "Datenanalyse - Data Analysis"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Datenquellen.html",
    "href": "Datenanalyse/Datenanalyse_Datenquellen.html",
    "title": "2  Datenquellen",
    "section": "",
    "text": "2.1 CSV-Dateien\nCSV-Dateien sind Textdateien, die Daten in Tabellenform speichern. CSV steht für Comma Separated Values. Die Werte in einer Zeile sind durch ein Trennzeichen getrennt, meistens ein Komma. Das Trennzeichen kann aber auch ein Semikolon oder ein Tabulator sein. Ein Beispiel für eine CSV-Datei könnte so aussehen:\nPraktisch ist es wenn die erste Zeile die Spaltennamen enthält. Zum Beispiel so:\nWenn die Spaltennamen erlaube Python Variablennamen sind, können die Daten nach dem einlesen direkt mit dem Namen der Spalte angesprochen werden.\nOf gibt es auch sogenannte Header Zeile. Hier wird sogenannte Metainformation gespeichert. Zum Beispiel die Einsteillungen eines messgerätes zum Zeitpunkt der Messung.\nDiese Header Zeilen müssen beim einlesen ignoriert werden. Werden Informationen daraus benötigt, müssen sie explizit ausgelesen werden.",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Datenquellen.html#csv-dateien",
    "href": "Datenanalyse/Datenanalyse_Datenquellen.html#csv-dateien",
    "title": "2  Datenquellen",
    "section": "",
    "text": "-5.056e-02,0.0599999,0.00399998\n-5.040e-02,0.0599999,0.012\n-5.024e-02,0.0599999,0.012\n-5.008e-02,0.0599999,0.012\n\nTIME,CH1,CH2\n-5.056e-02,0.0599999,0.00399998\n-5.040e-02,0.0599999,0.012\n-5.024e-02,0.0599999,0.012\n\nModel,TBS1072C\nFirmware Version,v2015-08-04-prequal4ch70_v1.3\n\nPoint Format,Y,\nHorizontal Units,S,\nHorizontal Scale,0.02,\nSample Interval,0.00016,\nFilter Frequency,2e+08,\nRecord Length,2000,\nGating,0.0% to 100.0%,0.0% to 100.0%\nProbe Attenuation,1,1\nVertical Units,V,V\nVertical Offset,0,0\nVertical Scale,1,0.2\nLabel,,\nTIME,CH1,CH2\n-5.056e-02,0.0599999,0.00399998\n-5.040e-02,0.0599999,0.012\n-5.024e-02,0.0599999,0.012\n-5.008e-02,0.0599999,0.012\n\n\n2.1.1 Einlesen von CSV-Dateien\nDa CSV ein sehr weit verbreitetes Format ist, gibt es auch in Python viele Möglichkeiten CSV-Dateien einzulesen. In diesem Dokument wird die Bibliothek pandas verwendet. Als Datensatz werden Daten eines Oszilloskops verwendet. Die Datei, TEK00003.CSV, ist auf Github zu finden.\nZuerst wird die Datei mit einem Texteditor geöffnet um sich einen Überblick über die Struktur zu verschaffen. und festzustellen ob es Header Zeilen gibt. In diesem Fall gibt es 15 Zeilen die ignoriert werden müssen.\n\nimport pandas as pd # Importieren der Bibliothek pandas\ndf = pd.read_csv('TEK00003.CSV',skiprows=15) # Einlesen der Datei und überspringen der ersten 15 Zeilen\ndisplay(df) # Ausgabe\n\n\n\n\n\n\n\n\n\nTIME\nCH1\nCH2\n\n\n\n\n0\n-0.05056\n0.06\n0.004\n\n\n1\n-0.05040\n0.06\n0.012\n\n\n2\n-0.05024\n0.06\n0.012\n\n\n3\n-0.05008\n0.06\n0.012\n\n\n4\n-0.04992\n0.06\n0.004\n\n\n...\n...\n...\n...\n\n\n1936\n0.25920\n4.98\n0.972\n\n\n1937\n0.25940\n5.02\n0.996\n\n\n1938\n0.25950\n5.02\n1.028\n\n\n1939\n0.25970\n5.02\n1.036\n\n\n1940\n0.25980\n4.98\n1.020\n\n\n\n\n1941 rows × 3 columns\n\n\n\n\nNun kann die Datenanalyse beginnen. Dazu aber in späteren Kapiteln.\nAls Testdaten kann zum Beispiel die Statistik der Programmiersprachen auf Github verwendet werden. Global-metrics programming-languages",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Datenquellen.html#bild",
    "href": "Datenanalyse/Datenanalyse_Datenquellen.html#bild",
    "title": "2  Datenquellen",
    "section": "2.2 Bild",
    "text": "2.2 Bild\nEs soll ein Bild eingelesen und die RGB in einem Pandas DataFrame gespeichert werden.\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg\n\nimg = mpimg.imread('htl-logo_rauten.bmp')\ndf = pd.DataFrame(img.reshape(-1,3),columns=['R','G','B'])\ndisplay(df)\n\n\n\n\n\n\n\n\n\nR\nG\nB\n\n\n\n\n0\n255\n255\n254\n\n\n1\n255\n255\n254\n\n\n2\n255\n255\n254\n\n\n3\n255\n255\n254\n\n\n4\n255\n255\n254\n\n\n...\n...\n...\n...\n\n\n74499\n234\n229\n224\n\n\n74500\n234\n229\n224\n\n\n74501\n235\n229\n224\n\n\n74502\n234\n229\n224\n\n\n74503\n236\n231\n227\n\n\n\n\n74504 rows × 3 columns",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Datenquellen.html#restful-api",
    "href": "Datenanalyse/Datenanalyse_Datenquellen.html#restful-api",
    "title": "2  Datenquellen",
    "section": "2.3 RESTful API",
    "text": "2.3 RESTful API\nEine RESTful API ist eine Schnittstelle, die auf dem HTTP-Protokoll basiert und die CRUD-Operationen (Create, Read, Update, Delete) unterstützt. Viele Webseiten und Dienste bieten eine RESTful API an, um Daten abzurufen oder zu speichern. Beispiele dafür sind soziale Netzwerke wie Twitter oder Facebook, Wetterdienste wie OpenWeatherMap oder Finanzdienste.\n\n2.3.1 Einlesen von Daten einer RESTful API\nIn diesem Beispiel wird die RESTful API von jsonplaceholder verwendet. Diese API stellt Testdaten zur Verfügung.\n\nimport requests\nimport pandas as pd\n\nurl = 'https://jsonplaceholder.typicode.com/posts'\nresponse = requests.get(url)\ndata = response.json()\ndf = pd.DataFrame(data)\ndisplay(df.head())\n\n\n\n\n\n\n\n\n\nuserId\nid\ntitle\nbody\n\n\n\n\n0\n1\n1\nsunt aut facere repellat provident occaecati e...\nquia et suscipit\\nsuscipit recusandae consequu...\n\n\n1\n1\n2\nqui est esse\nest rerum tempore vitae\\nsequi sint nihil repr...\n\n\n2\n1\n3\nea molestias quasi exercitationem repellat qui...\net iusto sed quo iure\\nvoluptatem occaecati om...\n\n\n3\n1\n4\neum et est occaecati\nullam et saepe reiciendis voluptatem adipisci\\...\n\n\n4\n1\n5\nnesciunt quas odio\nrepudiandae veniam quaerat sunt sed\\nalias aut...",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Datenquellen.html#datenbanken",
    "href": "Datenanalyse/Datenanalyse_Datenquellen.html#datenbanken",
    "title": "2  Datenquellen",
    "section": "2.4 Datenbanken",
    "text": "2.4 Datenbanken\nDatenbanken sind ein mächtiges Werkzeug um Daten zu speichern und zu verwalten. Der Aufbau und die Funktion wird an dieser Stelle nicht weiter erläutert und auf die entsprechende Unterrichtsfächer verwiesen.",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Datenquellen.html#mqtt",
    "href": "Datenanalyse/Datenanalyse_Datenquellen.html#mqtt",
    "title": "2  Datenquellen",
    "section": "2.5 MQTT",
    "text": "2.5 MQTT\nMQTT ist ein leichtgewichtiges Protokoll, das für die Kommunikation zwischen Geräten in einem Netzwerk entwickelt wurde. Es wird oft in IoT-Anwendungen verwendet. In diesem Beispiel wird die Bibliothek paho-mqtt verwendet.\n\nimport paho.mqtt.client as mqtt #import the mqtt client\nimport pandas as pd #import the pandas library\nimport time #import the time library\nimport json #import the json library\nfrom datetime import datetime, timedelta, date #import the datetime library\n\ndef on_connect(client, userdata, flags, rc): #define the on_connect function\n    client.subscribe(\"test\") #subscribe to the test topic, replace with your own topic\n\ndef on_message(client, userdata, msg): #define the on_message function\n    global val #make the val variable global\n    val = msg.payload.decode() #decode the message\n\nval = None #initialize the val variable\ndf = pd.DataFrame() #initialize the dataframe\nclient = mqtt.Client() #create a new mqtt client\nclient.on_connect = on_connect #set the on_connect function\nclient.on_message = on_message #set the on_message function\n\nmqtt_server_url = \"test.mosquitto.org\" #define the mqtt server url\nclient.connect(mqtt_server_url, 1883, 60) #connect to the mqtt server\n\nclient.loop_start() #start the loop\nvals = [] #initialize the vals list\ntimestamps = [] #initialize the timestamps list\nfor i in range(2): #run the loop for x times resulting in x messages being received\n    while val is None: #wait for the message to be received\n        time.sleep(0.1) #sleep for 0.1 seconds\n    timestamps.append(datetime.now()) #get the current date and time\n    vals.append(val) #load the json message\n    val = None #reset the val variable\n\ndf = pd.DataFrame(vals, index=timestamps) #create the dataframe\n   \nclient.loop_stop() #stop the loop\ndisplay(df) #display the dataframe\n\n\n\n\n\n\n\n\n\n0\n\n\n\n\n2024-05-02 08:19:58.531032\n1\n\n\n2024-05-02 08:19:59.535405\nhelloworld",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Datenquellen.html#weiterführende-links",
    "href": "Datenanalyse/Datenanalyse_Datenquellen.html#weiterführende-links",
    "title": "2  Datenquellen",
    "section": "2.6 Weiterführende Links",
    "text": "2.6 Weiterführende Links\nPandas Input/Output",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Darstellungsformen.html",
    "href": "Datenanalyse/Datenanalyse_Darstellungsformen.html",
    "title": "3  Darstellungsformen von Daten",
    "section": "",
    "text": "3.1 Zeitreihen\nDie Bezeichnung bezieht sich auf die Größe auf der x-Achse, die Zeit.\nimport pandas as pd # Importieren der Bibliothek pandas\nimport matplotlib.pyplot as plt # Importieren der Bibliothek matplotlib\n\ndf = pd.read_csv('TEK00003.CSV',skiprows=15) # Einlesen der Datei und überspringen der ersten 15 Zeilen\n#display(df) # Ausgabe\n\n# Erstellen des Diagramms\nplt.plot(df.TIME,df.CH1,label='Spannung am Eingang des Motors') # x-Achse: Zeit, y-Achse: Kanal 1\nplt.plot(df.TIME,df.CH2,label='Spannung am Ausgang des mechanisch gekoppelten Tachogenerators') # x-Achse: Zeit, y-Achse: Kanal 2\nplt.xlabel('Zeit in s') # Beschriftung der x-Achse\nplt.ylabel('Spannung in V') # Beschriftung der y-Achse\nplt.title('Sprungantwort eines DC-Motors') # Titel des Diagramms\nplt.grid() # Gitternetzlinien einblenden\nplt.legend(loc='upper center', bbox_to_anchor=(0.5, -0.1)) # Legende einblenden und Position anpassen\nplt.show() # Diagramm anzeigen\n\n\n\n\n\n\n\nAbbildung 3.2: Sprungantwort eines DC-Motors",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Darstellungsformen von Daten</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Darstellungsformen.html#histogramme---häufigkeitsverteilungen",
    "href": "Datenanalyse/Datenanalyse_Darstellungsformen.html#histogramme---häufigkeitsverteilungen",
    "title": "3  Darstellungsformen von Daten",
    "section": "3.2 Histogramme - Häufigkeitsverteilungen",
    "text": "3.2 Histogramme - Häufigkeitsverteilungen\n\nimport pandas as pd # Importieren der Bibliothek pandas\nimport matplotlib.pyplot as plt # Importieren der Bibliothek matplotlib\n\ndf = pd.read_csv('TEK00003.CSV',skiprows=15) # Einlesen der Datei und überspringen der ersten 15 Zeilen\n#display(df) # Ausgabe\n\n# Erstellen des Diagramms\nplt.hist(df.CH2,bins=50,edgecolor='black') # Erstellen des Histogramms\nplt.xlabel('Spannung in V') # Beschriftung der x-Achse\nplt.ylabel('Häufigkeit') # Beschriftung der y-Achse\nplt.title('Histogramm der Spannungen am Ausgang des Tachogenerators') # Titel des Diagramms\nplt.grid() # Gitternetzlinien einblenden\nplt.show() # Diagramm anzeigen\n\n\n\n\n\n\n\nAbbildung 3.3: Histogramm der Spannungen am Ausgang des Tachogenerators",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Darstellungsformen von Daten</span>"
    ]
  },
  {
    "objectID": "Datenanalyse/Datenanalyse_Darstellungsformen.html#tortendiagramme",
    "href": "Datenanalyse/Datenanalyse_Darstellungsformen.html#tortendiagramme",
    "title": "3  Darstellungsformen von Daten",
    "section": "3.3 Tortendiagramme",
    "text": "3.3 Tortendiagramme\nHier wird die Möglichkeit von Pandas genutzt, die Daten direkt aus einem Link [1] zu lesen. Aktuelle Daten zum Thema waren noch nicht verfügbar.\n\nimport matplotlib.pyplot as plt # Importieren der Bibliothek matplotlib\nimport pandas as pd # Importieren der Bibliothek pandas\n\n# Daten\ndf = pd.read_csv('https://www.data.gv.at/katalog/dataset/60a9f978-5c95-4b83-adbf-b9e3e15cdb34/resource/a687191a-0b39-4f51-94e5-6aeffcdafaec/download/stimmenprotokoll-burgermeisterwahl-2018.csv',sep=';')\n#display(df) # Ausgabe\n\n# Erstellen des Diagramms\n\n# Gruppieren der Daten\ndf_kandidaten = df[df.columns[5:]].sum() # Kandidaten\n\n# Erstellen des Tortendiagramms\nplt.pie(df_kandidaten,labels=df_kandidaten.index,autopct='%1.1f%%') # Erstellen des Tortendiagramms\nplt.title('Tortendiagramm der BürgermeisterInnenwahl 2018') # Titel des Diagramms\nplt.show() # Diagramm anzeigen\n\n\n\n\n\n\n\nAbbildung 3.4: Tortendiagramm der BürgermeisterInwahl 2018 [1]\n\n\n\n\n\n\n\n\n\n1. Innsbruck S (2018) Innsbrucker BürgermeisterInwahl 2018. https://www.data.gv.at/katalog/dataset/60a9f978-5c95-4b83-adbf-b9e3e15cdb34/resource/a687191a-0b39-4f51-94e5-6aeffcdafaec/download/stimmenprotokoll-burgermeisterwahl-2018.csv. Accessed 1 Mai 2024",
    "crumbs": [
      "Datenanalyse - Data Analysis",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Darstellungsformen von Daten</span>"
    ]
  },
  {
    "objectID": "SteuerRegel/01_SteuerRegel.html",
    "href": "SteuerRegel/01_SteuerRegel.html",
    "title": "Steuer- und Regelungstechnik",
    "section": "",
    "text": "In diesem Kapitel geht es darum wie wir Maschinen und Schaltungen dazu bringen, ein gewünschtes Verhalten zu zeigen. Zum Beipiel soll ein Roboterarm ein Werkstück von der Position A zur Position B stellen. Oder eine Drohne trotz Windes ihre Postion halten.\nWir sprechen von Steuern, wenn wir eine Befehlskette vorgeben und keine Möglichkeit haben auf Störungen einfluss zu nehmen.\nVon Regeln sprechen wir, wenn wir Informationen über das zu erreichende Ziel erhalten und damit auf Störungen eingehen können. Es gibt beim Regeln daher eine Feedbackschleife oder auch Rückkopplung genannt.",
    "crumbs": [
      "Steuer- und Regelungstechnik"
    ]
  },
  {
    "objectID": "SteuerRegel/01.02_Regelungstechnik.html",
    "href": "SteuerRegel/01.02_Regelungstechnik.html",
    "title": "4  Regelungstechnik",
    "section": "",
    "text": "4.1 Warum wir regeln",
    "crumbs": [
      "Steuer- und Regelungstechnik",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regelungstechnik</span>"
    ]
  },
  {
    "objectID": "SteuerRegel/01.02_Regelungstechnik.html#warum-wir-regeln",
    "href": "SteuerRegel/01.02_Regelungstechnik.html#warum-wir-regeln",
    "title": "4  Regelungstechnik",
    "section": "",
    "text": "Viele Aufgaben von Maschinen können auch durch Steuern umgesetzt werden. Eine Regelung erlaubt es aber, auf unerwünschte Einflüsse, sogenannte Störgrößen, zu reagieren. Als Beispiel soll der Tempomat, Geschwindigkeitsregelanlage, des Autos dienen. Die Aufgabe des Tempomates ist es, die Geschwindigkeit, Regelgröße, konstant zu halten. Als unerwünschte Einflüsse, Störgrößen, sind alle physikalischen Größen zu betrachten, welche die Geschwindigkeit beeinflussen. Beispiele sind die Steigung der Straße und Wind.\nDie Geschwindigkeit des Autos wird über die Leistung, Stellgröße, bestimmt. Führt die Straße Bergauf wird mehr Leistung für die gleiche Geschwindigkeit benötigt. Es muss also die Leistung laufend angepasst werden, um eine konstante Geschwindigkeit zu erhalten.\nBei einer Steuerung würde eine Leistung eingestellt werden und sich daraus eine Geschwindigkeit ergeben. Dieses wäre jedoch nur für einen voreingestellten Fall identisch mit der gewünschten Geschwindigkeit.",
    "crumbs": [
      "Steuer- und Regelungstechnik",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regelungstechnik</span>"
    ]
  },
  {
    "objectID": "SteuerRegel/01.02_Regelungstechnik.html#wie-wir-regeln---der-standardregelkreis",
    "href": "SteuerRegel/01.02_Regelungstechnik.html#wie-wir-regeln---der-standardregelkreis",
    "title": "4  Regelungstechnik",
    "section": "4.2 Wie wir regeln - Der Standardregelkreis",
    "text": "4.2 Wie wir regeln - Der Standardregelkreis\n\nRegeln ist ein Vorgang, bei dem der IST-Wert einer Größe gemessen und, durch Nachstellen der Stellgröße, dem SOLL-Wert angeglichen wird.\nDazu wird das Ergebnis an den Eingang zurück geführt und vom Sollwert subtrahiert. Es entsteht eine Rückkopplung. Durch das negative Vorzeichen handelt es sich um eine Rückkopplung im Spezialfall einer Gegenkopplung. Die Differenz aus dem Sollwert und dem zurückgeführten Istwert ist die sogenannte Regelabweichung welche über den Regler zur Stellgröße wird. Die Stellgröße ist nun die physikalische Größe die die Regelstrecke zum gewünschten Verhalten führt.\n\n\n\n\n\n\n\nAbbildung 4.1: Standardregelkreis\n\n\n\n\n4.2.1 Reglertypen\nEs kann zwischen zwei Arten von Reglern unterschieden werden. Erstere sind einfache Regler die die Stellgröße nur zwischen verschiedenen Zuständen hin und her Schalten können. Zum Beispiel Ein / Aus. Oder die Gänge eines Automatikgetriebes. Diese Regler werden unstetige Regler genannt. Unstetige Regler können gut mittels Hysteresen beschrieben werden.\nDer zweite Typ von Regler kann die Stellgröße kontinurierlich anpassen. Diese Regler werden stetige Regler genannt. Stetige Regler können gut mit mathematische Gleichungen im Laplacebereich beschrieben werden.",
    "crumbs": [
      "Steuer- und Regelungstechnik",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regelungstechnik</span>"
    ]
  },
  {
    "objectID": "SteuerRegel/01.02_Regelungstechnik.html#unstetige-regler",
    "href": "SteuerRegel/01.02_Regelungstechnik.html#unstetige-regler",
    "title": "4  Regelungstechnik",
    "section": "4.3 Unstetige Regler",
    "text": "4.3 Unstetige Regler\nKlassische unstetige Regler sind Bimetallschalter. Diese werden zum Beipiel bei Heizlüftern eingesetzt.\nIst der Raum, und damit das Bimetall kalt so ist der Kontakt geschlossen und der Lüfter läuft. Wird die Raumluft und damit das Bimetall warm wird der Kontakt geöffnet und der Lüfter hört auf zu heizen.\n\n\n\\(T_{ein}\\) … Einschaltschwelle\n\n\n\\(T_{aus}\\) … Ausschaltschwelle\n\n\n\\(T\\) … Temperatur\n\n\n\\(T_{ref}\\) … Referenz Temperatur\n\n\n\n\n\n\n\n\n\n\nAbbildung 4.2: Zweipunktregler eines einfachen Heizlüfters\n\n\n\n\n\n\n4.3.1 Zweipunktregler\nDer Zweipunktregler kann, wie der Name schon sagt, die Stellgröße zwischen zwei Zuständen schalten. Zum Beipiel die Heizung einschalten wenn die Temperatur zu niedrig ist und wieder Abschalten wenn die Temperatur hoch genug ist. Siehe dazu die Kennlinie Abbildung 4.2. Die Kennlinie stellt eine Hysterese dar. Die Umsetzung ist auch mittels Operationsverstärker möglich.",
    "crumbs": [
      "Steuer- und Regelungstechnik",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regelungstechnik</span>"
    ]
  },
  {
    "objectID": "SteuerRegel/01.02_Regelungstechnik.html#stetige-regler",
    "href": "SteuerRegel/01.02_Regelungstechnik.html#stetige-regler",
    "title": "4  Regelungstechnik",
    "section": "4.4 Stetige Regler",
    "text": "4.4 Stetige Regler\nFür das Verständnis von stetigen Reglern ist es hilfreich die Regelungstechnik mathematisch zu betrachten, da sich ein Regler sehr gut mit Formeln beschreiben und erklären lässt. In einem eigenen Kapitel soll behandelt werden wie Regler praxisnahe implementiert werden können.\nDer oben gezeigte Regelkreis, Abbildung 4.1, lässt sich mathematisch als Übertragungsfunktion beschreiben. Hier werden ausschließlich SISO (Single Input Single Output) und LTI (Linear Time Invariant) Systeme betrachtet. Das Bedeutet Systeme die einen Eingang und einen Ausgang haben. Jeder Block kann einzeln mit einer Übertragungsfunktion, analog der Vierpoltheorie, beschrieben werden. Wie auch in der Vierpoltheorie kann aber auch eine Verschaltung von Blöcken als Übertragungsfunktion beschrieben werden. Ein Block wird in der Regelungstechnik auch als Strecke bezeichnet.\n\n4.4.1 Die Übertragungsfunktion\n\n4.4.1.1 Motivation\nDie Übertragungsfunktion Beschreibt den Zusammenhang zwischen Ausgang und Eingang.\nIst die Übertragungsfunktion bekannt, so kann die Strecke und deren Verhalten (der Ausgang) auf verschiedene Eingänge berechnet werden. Dies wird auch Simulation genannt. Für Marketingzwecke könnte die Übertragungsfunktion auch als einfache Form eines “digitalen Zwillings” bezeichnet werden. Ist die Übertragungsfunktion mathematisch beschrieben, können Regler entworfen und getestet werden, ohne das tatsächliche physikalische Modell benutzen zu müssen. Dies ist speziell sinnvoll wenn, das physikalische System für Testzwecke nicht zur Verfügung steht bzw. nicht für Testzwecke geeignet ist. Eine Strecke (=physikalisches System) steht z.B. nicht zur Verfügung, wenn:\n\nEs sich geographisch woanders befindet\n\nEs für die Produktion benötigt wird\n\nEs noch nicht gebaut wurde\n\nEine Strecke (=physikalisches System) ist nicht geeignet für Testzwecke wenn z.B.:\n\nDas System sehr langsam ist (Heizung eines Gebäudes)\n\nEin fehlerhafter Regler großen Schaden anrichten kann\n\n\n\n4.4.1.2 Streckenidentifikation\nAls Streckenidentifiaktion wird der Vorgang beschrieben, von einem physikalischem System das mathematische Modell, die Übertragungsfunktion, zu erstellen. Zwei Methoden wie dieses Ziel erreicht werden kann, werden hier beschrieben.\n\nDer mathematische Ansatz, Kapitel 4.4.2\n\nDer messtechnische Ansatz, Kapitel 4.4.3\n\n\n\n\\[\nV = \\frac{A}{E}\n\\tag{4.1}\\]\n\n\n\\(V\\) … Verarbeitung, die Übertragungsfunktion\n\n\n\\(A\\) … Ausgang\n\n\n\\(E\\) … Eingang\n\n\nGängige Bezeichnungen der Übertragungsfunktion der einzelnen Blöcke ist wie folgt.\n\n\n\\(G\\) … Übertragungsfunktion der zu Regelnden Strecke\n\n\n\\(R\\) … Übertragungsfunktion des Reglers\n\n\n\\(M\\) … Übertragungsfunktion des Sensors\n\n\n\n\n\n4.4.2 Mathematische Streckenidentifikation\nAus den physikalischen Zusammenhängen kann die Übertragungsfunktion berechnet werden. Die komplexe Schreibweise ist nur für periodische sinusförmige Signale geeignet. Sollen Signale betrachtet werden die beliebig, stetig, sind ist die komplexe schreibweise nicht ausreichend. Es müssen die physikalischen Gleichungen in differentieller Form angeschrieben werden.\nUm die Mathematik möglichst einfach zu halten wird in der Regelungstechnik im Laplace Bereich gearbeitet. Dadurch ist es nicht notwendig die Diffenrentialgleichung bei physikalischen Systemen, die durch eine Differentialgleichung beschrieben werden, zu lösen.\nEin Besipiel, wie eine mathematische Streckenidentifikation abläuft ist in Abschnitt Kapitel 4.4.4 zu finden.\n\n\n4.4.3 Messtechnische Streckenidentifikation\nManche Systeme sind zu komplex um Sie mathematisch zu beschreiben. Andere Systeme sind mathematisch nicht beschreibbar, weil das Innenleben nicht bekannt ist. In diesen Fällen kann die messtechnische Ermittlung der Übertragungsfunktion herangezogen werden.\nDabei wird am Eingang der Strecke ein Testssignal aufgeschalten und der Ausgang gemessen. Aus diesen Messdaten kann die Übertragungsfunktion, ein mathemtisches Modell, der Strecke erstellt werden.\n\n\n4.4.4 Die Laplace Transformation\noder die Anstrengung der Faulen.\n\n4.4.4.1 Warum Laplace\nUm eine Übertragungsfunktion zu Berechnen muss der Ausgang durch den Eingang dividiert werden. Wird das physikalische System durch eine lineare Gleichung beschrieben ist das sehr Einfach möglich und die Laplace Transformation ist nicht notwendig. Ein Beispiel dafür is das Ohm’sche Gesetz.\n\n\n\\[\nR_{ohm} = \\frac{U}{I}\n\\tag{4.2}\\]\n\n\n\\(U\\) … Spannung am Widerstand als Ausgang\n\n\n\\(R_{ohm}\\) … Ohm’scher Widerstand als Übertragungsfunktion\n\n\n\\(I\\) … Strom am Widerstand als Eingang\n\n\nWird das physikalische System aber durch eine Differentialgleichung beschrieben, wie zum Beispiel bei einem Tiefpass, so wäre es notwendig zuerst die Differentialgleichung zu lösen um die Übertragungsfunktion zu berechnen. Hier bietet die Lapalce Transformation eine erhebliche erleichterung.\nWird die Übertragungsfunktion im Laplace-Bereich angeschrieben, ergeben sich weitere Vorteile, wenn es später darum geht einen Regler zu entwerfen und die Stabilität einer Strecke zu beurteilen.\n\n4.4.4.1.1 Beispiel Übertragungsfunktion eines Tiefapsses\n\n\n\n\n\n\nAbbildung 4.3: Tiefpass\n\n\n\n\n\n\\[\ni_{c}{\\left(t \\right)} = \\frac{\\frac{d}{d t} u_{c}{\\left(t \\right)}}{C}\n\\tag{4.3}\\]\n\n\n\\[\ni_{c}{\\left(t \\right)} = \\frac{- u_{c}{\\left(t \\right)} + u_{in}{\\left(t \\right)}}{R_{ohm}}\n\\tag{4.4}\\]\n\n\nDurch Gleichsetzten von Gleichung 4.3 und Gleichung 4.4 ergibt sich die allgemeine Differenzialgleichung 1. Ordnung für den Tiefpass.\n\n\n\\[\n\\frac{d}{d t} u_{c}{\\left(t \\right)} + \\frac{u_{c}{\\left(t \\right)}}{C R_{ohm}} = \\frac{u_{in}{\\left(t \\right)}}{C R_{ohm}}\n\\tag{4.5}\\]\n\n\n\\(R_{ohm}\\) … Ohmscher Widerstand\n\n\n\\(C\\) … Kapazität\n\n\n\\(t\\) … Zeit\n\n\n\\(u_{c}{\\left(t \\right)}\\) … Ausgangsspannung\n\n\n\\(i_{c}{\\left(t \\right)}\\) … Strom\n\n\n\\(u_{in}{\\left(t \\right)}\\) … Eingangsspannung\n\n\nMüsste nun von dieser Differentialgleichung die Übertragungsfunktion, also \\(G=Ausgang/Eingang\\), angegeben werden, so müsste zunächst die Differentialgleichung gelöst werden.\nDie Laplace Transformation bietet hier einen alternativen Weg der mit weiteren Vorteilen verbunden ist wenn es darum geht Blöcke miteinander zu kombinieren oder Aussagen über das System zu treffen.\n\n\n\n4.4.4.2 Laplacetransformation\nDie tiefere Mathematik der Laplacetransofrmation überlassen wir hier den Mathematiker:innen und den ersten Semstern eines Studiums. Wir wollen die Laplacetransformation lediglich als Werkzeug zur vereinfachung unserer Arbeit verwenden. Dazu benötigen wir folgende Grundregeln.\nVereinfacht ist die Laplacetransformation als eine Übersetzung aus dem Zeitbereich, also mit der varaible \\(t\\), in den Frequenzbereich mit der Variable \\(s\\) zu verstehen. Die Übersetzung erfolgt in vielen Fällen sehr einfach mittels Tabelle. Hier wird die Transformation nur für ausgewählte Signale und mathematische Operationen angeführt.\n\n\n\nTabelle 4.1: Laplacetransformationstabelle\n\n\n\n\n\n\n\n\n\n\nZeitbereich x(t)\nFrequenzbereich X(s)\nBemerkung\n\n\n\n\n\\(\\frac{d \\ x(t)}{d \\ t}\\)\n\\(s \\cdot X(s) - x(0)\\)\nTransformation der Ableitung nach der Zeit, \\(x(0)\\) ist dabei der Wert zum Zeitpunkt Null. Bei einem Kondensator wäre dies zum Beispiel der Ladezustand zu Beginn.\n\n\n\\({ \\int x(t) \\, d \\ t}\\)\n\\(\\frac{1}{s} \\cdot X(s)\\)\nTransformation der Integration über der Zeit\n\n\n\\(\\delta (t)\\)\n\\(1\\)\nTransformation des Impulses\n\n\n\\(\\sigma (t)\\)\n\\(\\frac{1}{s}\\)\nTransformation des Sprunges\n\n\n\\(e^{at}\\)\n\\(\\frac{1}{s -a}\\)\n\n\n\n\\(\\frac{1}{a} e^{\\frac{-t}{a}}\\)\n\\(\\frac{1}{1 + as}\\)\n\n\n\n\n\n\n\nWird nun Gleichung Gleichung 4.5 mittels der Tabelle Tabelle 4.1 transformiert erhalten wir eine Gleichung aus der wir durch einfaches Umformen eine Übertragungsfunktion erhalten. Es wird angenommen, dass $ x(0) = 0 $ ist.\n\n\n\\[\nU_{C} s + \\frac{U_{C}}{C R_{ohm}} = \\frac{U_{IN}}{C R_{ohm}}\n\\tag{4.6}\\]\n\n\n\\[\nG = \\frac{U_{C}}{U_{IN}}\n\\tag{4.7}\\]\n\n\n\\[\nG = \\frac{1}{C R_{ohm} + s}\n\\tag{4.8}\\]\n\n\n\n\n\n4.4.5 Testsignale und Streckenverhalten\n\n4.4.5.1 Testsignale\n\n\n4.4.5.2 Streckenverhalten\n\n4.4.5.2.1 Interaktiver PT2 Simulator\n\nPlot.plot({\n  y: {\n    grid: true,\n  //  domain: [0, 4]\n  },\n  marks: [\n    Plot.line(y, {\n      x: \"t\",\n      y: \"s\",\n      stroke: '#888'\n    }),\n    Plot.line(y, { x: \"t\", y: \"u\", stroke: '#34f' })\n  ]\n})\n\n\n\n\n\n\n\nviewof input = Select(\n  ['step', 'hardstep', 'smoothstep', 'ramp', 'quadratic ramp'],\n  {\n    value: 'step',\n    label: 'Input'\n  }\n)\n\n//viewof Kp = Range([1e-12, 100], {\n//  label: tex`K_P`,\n//  value: 1,\n//  transform: Math.log\n//})\n\n//viewof Ki = Range([1e-12, 10], {\n//  label: tex`K_I`,\n//  value: 0,\n//  transform: Math.log\n//})\n\n//viewof Kd = Range([1e-12, 1], {\n//  label: tex`K_d`,\n//  value: 0,\n//  transform: Math.log\n//})\n\n//viewof dt = Range([1e-4, 0.1], {\n//  value: 0.001,\n//  transform: Math.log,\n//  label: tex`\\Delta t`\n//})\n\nviewof Kpt2 = Range([1e-12, 5], {\n  value: 1,\n  transform: Math.log,\n  label: tex`K_{pt2}`\n})\n\nviewof D = Range([1e-12, 10], {\n  value: 0.5,\n  transform: Math.log,\n  label: tex`D`\n})\n\nviewof T = Range([1e-12, 5], {\n  value: 1,\n  transform: Math.log,\n  label: tex`T`\n})\n\nviewof tMax = Range([1, 10e3], {\n  value: 10,\n  transform: Math.log,\n  label: tex`t_{max}`\n})\n\ny = {\n  const output = [];\n\n  let p; \n  let t0 = -0.5;\n  //let tMax = 20;\n\n  let t = t0;\n  let d = 0;\n  let u = 0;\n  let i = 0;\n  let e = 0;\n  let eprev = e;\n  let pu = u;\n  let ppu = u;\n  let du = 0;\n  let ddu = 0;\n  let pdu = 0;\n  let y = 0;\n  let py = 0;\n  let ppy = 0;\n  let dy = 0;\n  let ddy = 0;\n  let pdy = 0;\n  let de = 0;\n  let dt = 0.001;\n  let s = setPoint(t0);\n  output.push({ t, u, s });\n\n  let j = 1;\n  while (t &lt; tMax) {\n    t = t0 + j * dt;\n\n    s = setPoint(t);\n   \n    e = s - u;\n    de = eprev-e;\n\n    //du = (u-pu)/dt;\n    //ddu = (du - pdu)/dt;\n\n    //dy = (py - y)/dt;\n    //ddy = (dy - pdy)/dt;\n\n    p = e;\n    i += e * dt;\n    d = de/dt;\n\n    y = s; //(Kp * p + Ki * i + Kd * d) * dt;\n    \n    u = (2*D*T*dt*pu + Kpt2*dt**2*y - T**2*ppu + 2*T**2*pu)/(2*D*T*dt + T**2 + dt**2);\n\n    ppu = pu;\n    pu = u;\n    //pdu = du;\n\n    //ppy = py;\n    //py = y;\n    //pdy = dy;\n\n    eprev = e;\n\n    output.push({ t, u, s });\n    j++;\n  }\n\n  return output;\n}\n\nsetPoint = {\n  function hardstep(x) {\n    return Math.max(0, Math.min(1, x));\n  }\n  function smoothstep(x) {\n    var x = hardstep(x);\n    return x * x * (3 - 2 * x);\n  }\n  switch (input) {\n    case 'step':\n      return t =&gt; (t &gt;= 0 ? 1 : 0);\n    case 'ramp':\n      return t =&gt; (t &gt;= 0 ? t : 0);\n    case 'quadratic ramp':\n      return t =&gt; (t &gt;= 0 ? t * t : 0);\n    case 'smoothstep':\n      return smoothstep;\n    case 'hardstep':\n      return hardstep;\n    default:\n      throw new Error('Invalid input');\n  }\n}\n\nimport { Range, Select } from '@observablehq/inputs'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.4.5.3 Identifikation\n\n\n\n4.4.6 Zusammenschaltung von Blöcken\nWerden Blöcke kombiniert können die resultierenden Übertragungsfunktionen berechnet werden.\nZur vereinfachung kann die Übertragungsfunktion des Sensors mit \\(M=1\\) angenommen werden, \\(M=1\\), wenn dieser im Verhälnis zur Strecke und zum Regler vernachlässigbar ist. Dies ist zum Beispiel der Fall wenn der Sensor viel schneller ist als die Strecke und der Regler. Diese Vorraussetzung ist für viele Systeme gegeben.\nFür den Regelkreis, Abbildung 4.1, ergebn sich folgende Möglichkeiten.\n\n4.4.6.1 Die Führungsübertragungsfunktion\nDie Führungsübertragungsfunktion gibt das Verhältnis zwischen Sollgröße und Istgröße an. Sie Beschreibt damit das Verhalten des Regelkreises mit der Sollgröße als Eingang und der Istgröße als Ausgang. Ist eine Regelstrecke ideal so ist die die Führungsübertragungsfunktion gleich Eins.\n\n\n\\[\nF_{w} = \\frac{G R}{G M R + 1}\n\\tag{4.9}\\]\n\n\n\\(F_{w}\\) … Führungsübertragungsfunktion\n\n\n\n\n4.4.6.2 Die Schleifenübertragungsfunktion\nDie Schleifenübertragungsfunktion ist die Übertragungsfunktion des offenen Regelkreises, also ohne Rückkopplung und ist im Laplace Bereich eine einfache Multiplikation.\n\n\n\\[\nF_{o} = G R\n\\tag{4.10}\\]\n\n\n\\(F_{o}\\) … Schleifenübertragungsfunktion\n\n\n\n\n4.4.6.3 Die Störübertragungsfunktion\nDie Störübertragungsfunktion beschreibt wie sich die Störgröße auf den Ausgang auswirkt.\n\n\n\\[\nF_{s} = \\frac{G}{F_{o} + 1}\n\\tag{4.11}\\]\n\n\n\\(F_{s}\\) … Störübertragungsfunktion\n\n\n\n\n\n4.4.7 Interaktiver PID Simulator\n Eingangssignal \\(w\\) \n Ausgangssignal \\(y\\) \n Regelabweichung \\(e\\) \n Stellgröße \\(u\\) \n\n// The basic code layout was found on source: https://observablehq.com/@mbostock/inputs\n// be aware, the code variables do not yet match the variable names in the document\n\nPlot.plot({\n  y: {\n    grid: true,\n  //  domain: [0, 4]\n  },\n  marks: [\n    Plot.line(y_PID, {\n      x: \"t_PID\",\n      y: \"s_PID\",\n      stroke: '#888'\n    }),\n    Plot.line(y_PID, { x: \"t_PID\", y: \"u_PID\", stroke: '#34f' }), //BLue\n    Plot.line(y_PID, { x: \"t_PID\", y: \"e_PID\", stroke: '#fb2f03' }), //RED\n    Plot.line(y_PID, { x: \"t_PID\", y: \"y_PID\", stroke: '#d7fb03' }),  //Greenisch\n  ]\n})\n\n\n\n\n\n\nReglereinstellungen:\n\nviewof Kp_PID = Range([1e-12, 10e3], {\n  label: tex`K_P`,\n  value: 1,\n  transform: Math.log\n})\n\nviewof Ki_PID = Range([1e-12, 10e2], {\n  label: tex`K_I`,\n  value: 0,\n  transform: Math.log\n})\n\nviewof Kd_PID = Range([1e-12, 10e1], {\n  label: tex`K_d`,\n  value: 0,\n  transform: Math.log\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStreckeneinstellungen:\n\nviewof Kpt2_PID = Range([1e-12, 10e3], {\n  value: 1,\n  transform: Math.log,\n  label: tex`K_{pt2}`\n})\n\nviewof D_PID = Range([1e-12, 10], {\n  value: 1,\n  transform: Math.log,\n  label: tex`D`\n})\n\nviewof T_PID = Range([1e-12, 5], {\n  value: 1,\n  transform: Math.log,\n  label: tex`T`\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAuswahl Eingangssignal:\n\nviewof input_PID = Select(\n  ['step', 'hardstep', 'smoothstep', 'ramp', 'quadratic ramp'],\n  {\n    value: 'step',\n    label: 'Input'\n  }\n)\n\n\n\n\n\n\nSimulationseinstellungen:\n\nviewof tMax_PID = Range([1, 10e3], {\n  value: 10,\n  transform: Math.log,\n  label: tex`t_{max}`\n})\n\ny_PID = {\n  const output_PID = [];\n\n  let p_PID; \n  let t0_PID = -0.5;\n  //let tMax_PID = 20;\n\n  let t_PID = t0_PID;\n  let d_PID = 0;\n  let u_PID = 0;\n  let i_PID = 0;\n  let e_PID = 0;\n  let eprev_PID = e_PID;\n  let pu_PID = u_PID;\n  let ppu_PID = u_PID;\n  let du_PID = 0;\n  let ddu_PID = 0;\n  let pdu_PID = 0;\n  let y_PID = 0;\n  let py_PID = 0;\n  let ppy_PID = 0;\n  let dy_PID = 0;\n  let ddy_PID = 0;\n  let pdy_PID = 0;\n  let de_PID = 0;\n  let dt_PID = 0.001;\n  let s_PID = setPoint(t0_PID);\n  output_PID.push({ t_PID, u_PID, s_PID });\n\n  let j_PID = 1;\n  while (t_PID &lt; tMax_PID) {\n    t_PID = t0_PID + j_PID * dt_PID;\n\n    s_PID = setPoint_PID(t_PID);\n   \n    e_PID = s_PID - u_PID;\n    de_PID = eprev_PID-e_PID;\n\n    //du = (u-pu)/dt;\n    //ddu = (du - pdu)/dt;\n\n    //dy = (py - y)/dt;\n    //ddy = (dy - pdy)/dt;\n\n    p_PID = e_PID;\n    i_PID += e_PID * dt_PID;\n    d_PID = de_PID/dt_PID;\n\n    y_PID = (Kp_PID * p_PID + Ki_PID * i_PID + Kd_PID * d_PID);\n    \n    u_PID = (2*D_PID*T_PID*dt_PID*pu_PID + Kpt2_PID*dt_PID**2*y_PID - T_PID**2*ppu_PID + 2*T_PID**2*pu_PID)/(2*D_PID*T_PID*dt_PID + T_PID**2 + dt_PID**2);\n\n    ppu_PID = pu_PID;\n    pu_PID = u_PID;\n    //pdu = du;\n\n    //ppy = py;\n    //py = y;\n    //pdy = dy;\n\n    eprev_PID = e_PID;\n\n    output_PID.push({ t_PID, u_PID, s_PID, e_PID, y_PID });\n    j_PID++;\n  }\n\n  return output_PID;\n}\n\nsetPoint_PID = {\n  function hardstep_PID(x) {\n    return Math.max(0, Math.min(1, x));\n  }\n  function smoothstep_PID(x) {\n    var x = hardstep_PID(x);\n    return x * x * (3 - 2 * x);\n  }\n  switch (input) {\n    case 'step':\n      return t_PID =&gt; (t_PID &gt;= 0 ? 1 : 0);\n    case 'ramp':\n      return t_PID =&gt; (t_PID &gt;= 0 ? t_PID : 0);\n    case 'quadratic ramp':\n      return t_PID =&gt; (t_PID &gt;= 0 ? t_PID * t_PID : 0);\n    case 'smoothstep':\n      return smoothstep_PID;\n    case 'hardstep':\n      return hardstep_PID;\n    default:\n      throw new Error('Invalid input');\n  }\n}",
    "crumbs": [
      "Steuer- und Regelungstechnik",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Regelungstechnik</span>"
    ]
  }
]